1. Find all Component classes, Find all Behavior classes.

For components:
1. Injectable fields needed for initialization;
2. Any flagged fields;
3. Any alias methods.
    - resolve duplicate aliases for methods within the same class
    - for methods within different classes (from previous projects)
    - For this, save all aliases (the names) in a global list (hash set).


For behaviors:
1. All component stuff;
2. Exported methods;
3. Exported method argument types and names;
4. Context type and field types and names. Any entity type should be treated differently;
5. Extract correct arguments form the context:
    - based on types and names of the arguments 
    - e.g. `Entity actor` must match by name and checked agains the `Context` type
    - e.g. `SomeComponent component` must get the component from actor
    - e.g. `SomeComponent other_component` must get the component from `other` entity from `Context`
    - e.g. `Context ctx` must be passed along
    - there is also `ref` and `out`. `out` sets the field on context.
    ```c#
        Method(Entity entity, var new_someValue);
        ctx.someValue = new_someValue
    ```
6. Figure out json file format for the listed dependencies and chain presets.
7. Convert json files into some intermediate representation????
8. Use the info gathered from json files to autogenerate presets / generate presets from json files on the fly.
    - detect the used namespaces (maybe explicitly import them in json)
    - warn on ambiguous references
    - error out on nonexistent symbols (check the types)
9. Set the priority numbers in a static init method for every behavior.
10. Construct chains from the handler names; Generate code for doing this in the init method.
11. Since the init method is going to grow depending on the type of the component/behavior/tag, it should be either made dependent on that or make different partial templates for the types. There is not going to be that much repetition of code, although I would like to eliminate it altogether.
12. If `autoactivation` is provided, 
    - check if it does not conflict with the specified chains (they must contain at least `Check` and `Do` or not be specified)
    - set `Check` and `Do` chains automatically, if no `Chains` attribute has been specified
    - deduce the arguments. If the `Context` field have an explicit default parameter, do not take those values.
    - check if no activation method exists with the deduced signature (allow activation methods with less arguments that reference the autogenerated activation).
    - generate the activation method from the template. It must take an Entity by default as the first parameter, so, it the context, the entity must be the first parameter! 
    - disregard properties on the context.
13. There is nothing complicated with chains: it's just reading one attribute.