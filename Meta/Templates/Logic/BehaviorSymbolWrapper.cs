using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Meta
{
    public class ChainWrapper
    {
        public string Name;
        public bool ShouldGenerateParamsMethod; 
        public bool ShouldGenerateTraverseMethod;

        public ChainWrapper(string name, INamedTypeSymbol parentSymbol)
        {
            Name = name;
            ShouldGenerateParamsMethod = parentSymbol.GetMembers().OfType<IMethodSymbol>().Any(m => m.Name == name);;
            ShouldGenerateTraverseMethod = parentSymbol.GetMembers().OfType<IMethodSymbol>().Any(m => m.Name == $"Traverse{name}");;
        }
    }

    public class BehaviorSymbolWrapper : ComponentSymbolWrapper
    {
        public ContextSymbolWrapper context;
        public AliasMethodSymbolWrapper[] aliasMethods;
        public ExportedMethodSymbolWrapper[] exportedMethods;
        public bool ShouldGenerateActivation;
        public ChainWrapper[] chains;

        public override string TypeText() => "behavior";

        public BehaviorSymbolWrapper(INamedTypeSymbol symbol, HashSet<string> globalAliases) : base(symbol, globalAliases)
        {
            Init();
        }

        private void Init()
        {
            // Initialize the context class symbol wrapper
            var ctx_symbol = symbol.GetMembers().FirstOrDefault(s => s.Name == "Context");
            if (ctx_symbol == null)
            {
                throw new Exception($"The {symbol.Name} behavior did not define a nested Context class.\n Note: Any behavior must define a Context class. If you do not have any chains in the behavior, make it a simple component. Behaviors by design differ from components in that they exploit chains.");
            }
            if (ctx_symbol.Kind != SymbolKind.NamedType)
            {
                throw new Exception($"The Context defined inside {symbol.Name} must be a class");
            }
            context = new ContextSymbolWrapper((INamedTypeSymbol)ctx_symbol);

            // See if we have the AutoActivation attribute
            var autoActivation = symbol.GetAttributes().SingleOrDefault(a => 
                SymbolEqualityComparer.Default.Equals(a.AttributeClass, RelevantSymbols.Instance.autoActivationAttribute));
            
            // Get the chains
            var chainsAttribute = symbol.GetAttributes().SingleOrDefault(a =>
                SymbolEqualityComparer.Default.Equals(a.AttributeClass, RelevantSymbols.Instance.chainsAttribute));
            
            if (autoActivation == null && chainsAttribute == null)
            {
                throw new Exception($"The behavior {symbol.Name} must be decorated with either the AutoActivation attrbiute, in which case the chains generated by default will be Check and Do, and/or with the Chains attribute, which will provide autogeneration for the specified chain names.");
            }

            chains = chainsAttribute == null

                ? new ChainWrapper[] { 
                    new ChainWrapper("Check", symbol), 
                    new ChainWrapper("Do", symbol) }

                : chainsAttribute.ConstructorArguments
                    .Select(arg => new ChainWrapper((string)arg.Value, symbol)).ToArray();


            ShouldGenerateActivation = autoActivation != null;

            if (ShouldGenerateActivation 
                && (!chains.Any(c => c.Name == "Check") || !chains.Any(c => c.Name == "Do")))
            {
                throw new Exception($"The behavior {symbol.Name} asked for an autogenerated activation but did not specify the necessary Check and Do chains. Be sure to either omit the Chains attibute altogether, when using the AutoActivation attrbiute, or append Check and Do to the list of chains.");
            }

            // Export methods
            exportedMethods = symbol.GetMembers().OfType<IMethodSymbol>()
                .Where(m => m.GetAttributes().Any(a =>
                        SymbolEqualityComparer.Default.Equals(a.AttributeClass, RelevantSymbols.Instance.exportAttribute)))
                .Select(m => new ExportedMethodSymbolWrapper(this, m))
                .ToArray();
        }
    }

    public static class IEnumerableExtensions
    {
        public static IEnumerable<U> FilterMap<T, U>(this IEnumerable<T> sequence, System.Func<T, U> map)
        {
            foreach (var element in sequence)
            {
                var result = map(element);
                if (result != null) yield return result;
            }
        }
    }
}