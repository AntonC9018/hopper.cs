using Hopper.Shared.Attributes;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Hopper.Meta
{
    public class BehaviorSymbolWrapper : ComponentSymbolWrapper
    {
        public ContextSymbolWrapper context;
        public bool ShouldGenerateAutoActivation;
        public bool ShouldGenerateCheckDo;
        public string ActivationAlias;

        public ChainWrapper[] chains;
        public bool HasCheck() => chains.Any(chain => chain.Name == "Check");
        public bool HasDo() => chains.Any(chain => chain.Name == "Do");
        public bool ShouldGenerateActivationShortcuts => ActivationAlias != null;

        public override string TypeText => "behavior";

        public BehaviorSymbolWrapper(INamedTypeSymbol symbol) : base(symbol)
        {
        }

        public bool InitContext(GenerationEnvironment env)
        {
            // Initialize the context class symbol wrapper
            var ctx_symbol = symbol.GetMembers().FirstOrDefault(s => s.Name == "Context");
            if (ctx_symbol == null)
            {
                env.ReportError($"The {symbol.Name} behavior did not define a nested Context class.\nNote: Any behavior must define a Context class. If you do not have any chains in the behavior, make it a simple component. Behaviors by design differ from components in that they exploit chains.");
                return false;
            }
            if (ctx_symbol.Kind != SymbolKind.NamedType)
            {
                env.ReportError($"The Context defined inside {symbol.Name} must be a class");
                return false;
            }
            context = new ContextSymbolWrapper((INamedTypeSymbol) ctx_symbol);
            return context.Init(env);
        }

        public override bool Init(GenerationEnvironment env)
        {
            env.errorContext.ClearFlag();

            if (!(base.Init(env) && InitContext(env) && env.TryAddComponent(this))) return false;

            if (!symbol.TryGetAttribute(RelevantSymbols.ChainsAttribute, out ChainsAttribute chainsAttribute))
            {
                chains = chainsAttribute.Chains
                    .Select(name => new ChainWrapper(name, symbol))
                    .ToArray();
            }

            // See if we have the AutoActivation attribute
            symbol.TryGetAttribute(RelevantSymbols.AutoActivationAttribute, out var autoActivation); 

            if (!symbol.HasAttribute(RelevantSymbols.NoActivationAttribute.symbol)) 
            {
                if (!(autoActivation is null) && chainsAttribute is null)
                {
                    env.ReportError($"Behaviors must be decorated with either the AutoActivation attribute, in which case the chains generated by default will be Check and Do, and/or with the Chains attribute, which will provide autogeneration for the specified chain names.");
                }

                if (chainsAttribute is null)
                {
                    chains = new ChainWrapper[] { 
                        new ChainWrapper("Check", symbol), 
                        new ChainWrapper("Do", symbol)
                    };
                }

                ShouldGenerateAutoActivation = autoActivation != null;
                ShouldGenerateCheckDo        = HasCheck() && HasDo();

                if (ShouldGenerateAutoActivation && !ShouldGenerateCheckDo)
                {
                    env.ReportError($"The behavior {symbol.Name} asked for an autogenerated activation but did not specify the necessary Check and Do chains. Be sure to either omit the Chains attibute altogether when using the AutoActivation attribute, or append Check and Do to the list of chains.");
                }

                // Find activation alias attribute
                symbol.TryGetAttribute(RelevantSymbols.ActivationAliasAttribute, out var activation);

                if (autoActivation != null)
                {
                    if (activation != null)
                    {
                        env.ReportError($"Found a request for automatic generation of an activation method beside the ActivationAlias attribute in the behavior {symbol.Name}. This is not allowed.");
                    }
                    else
                    {
                        // See AutoActivationAttribute. It always takes in one argument.
                        ActivationAlias = activation.Alias;
                    }
                }
                else if (activation == null)
                {
                    env.ReportError($"The behavior {symbol.Name} neither provided an activation method marked for aliasing (mark the class with ActivationAlias attibute and define a function named Activate that takes in the following arguments: {context.JoinedParamTypeNames()}), nor asked for automatic generation of an activation method (mark the class with the AutoActivation attribute). You must do at least one of these. \nAlternatively, mark the behavior with the NoActivation attribute to skip code generation for activation altogether.");
                }
                else
                {
                    // See ActivationAliasAttribute. It always takes in one argument.
                    ActivationAlias = activation.Alias;
                    
                    // Make sure there is a method that takes the same arguments that the context expects
                    var activationMethods = symbol.GetMembers()
                        .OfType<IMethodSymbol>()
                        .Where(m => m.Name == "Activate")
                        .Where(m => m.ParameterTypesEqual(context.notOmitted) 
                            || (m.Parameters.FirstOrDefault()?.Type == RelevantSymbols.entity 
                                && m.Parameters.Skip(1).TypeSequenceEqual(context.notOmitted)));

                    if (activationMethods.Count() == 0)
                    {
                        env.ReportError($"No suitable activation method found for the {symbol.Name} behavior. To resolve, provide an activation method that would take the following arguments: {context.JoinedParamTypeNames()}\nAlternatively, apply the AutoActivation attribute for such a method to be generated automatically.\nYou may also apply the Omit attribute to members of your Context class or give them default values, if the activation must not require them.\nAlternatively, mark the behavior with the NoActivation attribute to skip code generation for activation altogether.");
                    }
                }

                if (env.aliases.Contains(ActivationAlias))
                {
                    env.ReportError($"Duplicate alias name {ActivationAlias} in behavior {symbol.Name}.");
                }
            }
            else
            {
                if (autoActivation != null)
                {
                    env.ReportError($"The behavior {symbol.Name} both the NoActivation attribute and AutoActivation attribute were found. You must remove one or the other.");
                }

                if (chainsAttribute == null)
                {
                    chains = new ChainWrapper[0];
                }
            }

            return env.errorContext.Flag;
        }

        // This must be called after all the behaviors have been added to the dictionary
        // Since this could query them for context and chains.
        public override void AfterInit(GenerationEnvironment projectContext)
        {
            exportedMethods = GetAllExportedMethods(projectContext).ToArray();
        }

        private IEnumerable<ExportedMethodSymbolWrapper> GetAllExportedMethods(GenerationEnvironment env)
        {
            foreach (var method in GetMethods())
            {
                if (method.TryGetExportAttribute(out var attribute))
                {
                    // If the chain string is null, it means that the methods reference the behavior
                    // class they are defined in. 
                    // TODO: This actually does have to specify the chain, just without the behavior class part.
                    // Either specify these two separately, as in Chain = "Do", Behavior = "Attackable"
                    // Or split by dot at this point.
                    if (attribute.Chain == null)
                    {
                        yield return new ExportedMethodSymbolWrapper(this, method, attribute);
                    }
                    else
                    {
                        yield return new ExportedMethodSymbolWrapper(env, method, attribute);
                    }
                }
            }
        }
        
    }

    public static class IEnumerableExtensions
    {
        public static IEnumerable<U> FilterMap<T, U>(this IEnumerable<T> sequence, System.Func<T, U> map)
        {
            foreach (var element in sequence)
            {
                var result = map(element);
                if (result != null) yield return result;
            }
        }
    }
}