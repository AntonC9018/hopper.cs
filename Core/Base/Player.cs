using System.Runtime.Serialization;
using Hopper.Core.Components.Basic;
using Hopper.Core.Items;
using Hopper.Core.Retouchers;
using Hopper.Core.Stats.Basic;
using Hopper.Core.Targeting;
using Hopper.Core.History;
using Hopper.Core.Stats;

namespace Hopper.Core
{
    [DataContract]
    public static class Player
    {
        /*
            {
                name: "Player",
                components: [
                    
                    { name = "Acting"
                    , "_DoAction" = "SimpleAlgo", // the default should be this?
                    , "_CalculateAction" = null   // should not be required
                    },

                    { name = "

                    }
                ]
            }
        */

        public static void AddComponents(Entity subject)
        {
            // Apply these one after the other.
            // This will only initialize the inject variables of the behavior / component.
            // So, apply will be autogenerated for the different behaviors based on their injects.
            // Or do it even smarter? 
            // So, since I'd like to make components structs in the future and store them somewhere
            // central (optionally), these can actually reference a global storage for them.
            
            // So this just adds the behavior
            Acting  .AddTo(subject, null, null);
            Moving  .AddTo(subject);
            Digging .AddTo(subject);
            Pushable.AddTo(subject);
            Statused.AddTo(subject);
            Attacking   .AddTo(subject);
            Attackable  .AddTo(subject, Attackness.ALWAYS);
            Damageable  .AddTo(subject, new Health(5));
            Displaceable.AddTo(subject, ExtendedLayer.BLOCK);
            Ticking.AddTo(subject);

            FactionComponent.AddTo(subject, Faction.Player);
            TransformComponent.AddTo(subject);
            Inventory.AddTo(subject);

            // TODO: pass this an action
            Controllable.AddTo(subject, null);

            // TODO: rename the namespaces
            Stats.Stats.AddTo(subject);
            History.History.AddTo(subject);
        }

        public static void InitComponents(Entity subject)
        {
            subject.TryGetActing()? .DefaultPreset(subject);
            subject.TryGetMoving()? .DefaultPreset();
            subject.TryGetDigging()?.DefaultPreset();
            subject.TryGetTicking()?.DefaultPreset();
            subject.TryGetPushable()?  .DefaultPreset();
            subject.TryGetStatused()?  .DefaultPreset();
            subject.TryGetAttacking()? .DefaultPreset();
            subject.TryGetAttackable()?.DefaultPreset();
            subject.TryGetDamageable()?.DefaultPreset();
            subject.TryGetDisplaceable()?.DefaultPreset();
            // subject.TryGetFactionComponent()?.
            // subject.TryGetTransformComponent()?.
            // subject.TryGetInventory()?.
            // subject.TryGetControllable()?.
            // subject.TryGetStats()?.
            // subject.TryGetHistory()?.
        }

        public static void Retouch(Entity subject)
        {
            Skip.SkipEmptyAttackHandlerWrapper.AddTo(subject);
            Skip.SkipEmptyAttackHandlerWrapper.AddTo(subject);
            Equip.OnDisplaceHandlerWrapper.AddTo(subject);
            Reorient.OnActionSuccessHandlerWrapper.AddTo(subject);
        }
    }
}