using System.Runtime.Serialization;
using Hopper.Core.Components.Basic;
using Hopper.Core.Items;
using Hopper.Core.Retouchers;
using Hopper.Core.Stats.Basic;
using Hopper.Core.Targeting;

namespace Hopper.Core
{
    [DataContract]
    public static class Player
    {
        /*
            {
                name: "Player",
                components: [
                    
                    { name = "Acting"
                    , "_DoAction" = "SimpleAlgo", // the default should be this?
                    , "_CalculateAction" = null   // should not be required
                    },

                    { name = "

                    }
                ]
            }
        */

        public override Faction Faction => Faction.Player;

        public static void CreateFactory(Entity subject)
        {
            // Apply these one after the other.
            // This will only initialize the inject variables of the behavior / component.
            // So, apply will be autogenerated for the different behaviors based on their injects.
            // Or do it even smarter? 
            // So, since I'd like to make components structs in the future and store them somewhere
            // central (optionally), these can actually reference a global storage for them.
            
            // So this just adds the behavior
            Acting.Apply(subject, null, null);
            
            // Then you could also check if something has already been applied:
            if (subject.HasActing())
            {}

            // Next, it needs to be initialized. This has to be done after 
            // We've added all the other ones.
            Moving      .Apply(subject);
            Displaceable.Apply(subject);
            Attackable  .Apply(subject, Attackness.ALWAYS);
            Damageable  .Apply(subject, new Health(5));
            Attacking   .Apply(subject);
            Digging     .Apply(subject);
            Pushable    .Apply(subject);

            
            return new EntityFactory<Player>()
                .AddBehavior(Acting.Preset(new Acting.Config(Algos.SimpleAlgo, null)))
                .AddBehavior(Moving.Preset)
                .AddBehavior(Displaceable.DefaultPreset)
                // .AddBehavior(Controllable.Preset) // needs to be reconfigured
                .AddBehavior(Attackable.DefaultPreset)
                .AddBehavior(Damageable.Preset)
                .AddBehavior(Attacking.Preset)
                .AddBehavior(Digging.Preset)
                .AddBehavior(Pushable.Preset)
                .Retouch(Skip.EmptyAttack)
                .Retouch(Skip.EmptyDig)
                .Retouch(Equip.OnDisplace)
                .Retouch(Reorient.OnActionSuccess)
                .AddInitListener(e => e.Inventory = new Inventory(e));
        }
    }
}